<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gauge BLE Web UI</title>
  <style>
    :root{
      --bg:#0b0e14; --bg-2:#111620; --bg-3:#0f1420; --fg:#e6edf3; --muted:#a0a8b0;
      --acc:#4ea1ff; --warn:#ffb86b; --err:#ff6b6b; --line:#1f2633; --pill:#182235;
      --radius:14px; --shadow:0 8px 24px rgba(0,0,0,.35);
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      --sans: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:var(--sans);line-height:1.35}
    header{position:sticky;top:0;background:linear-gradient(180deg,rgba(11,14,20,.95),rgba(11,14,20,.80));backdrop-filter:saturate(160%) blur(6px);z-index:10;border-bottom:1px solid var(--line)}
    .bar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 16px}
    .title{font-weight:700;letter-spacing:.2px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-flex;align-items:center;gap:6px;background:var(--pill);border:1px solid var(--line);padding:4px 10px;border-radius:999px;font-size:12px;color:var(--muted)}
    main{padding:18px;max-width:1100px;margin:0 auto}
    .card{background:var(--bg-2);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:10px}
    label{display:block;font-size:12px;color:var(--muted);margin:4px 0}
    input[type="text"], textarea{width:100%;padding:10px;border:1px solid var(--line);background:var(--bg-3);color:var(--fg);border-radius:10px}
    button{padding:9px 12px;border-radius:12px;border:1px solid var(--line);background:var(--bg-3);color:var(--fg);cursor:pointer;transition:.15s ease}
    button:hover{transform:translateY(-1px);box-shadow:0 6px 18px rgba(0,0,0,.35)}
    button.primary{background:var(--acc);border-color:transparent;color:#041224}
    button.ghost{background:transparent}
    button:disabled{opacity:.5;cursor:not-allowed;transform:none;box-shadow:none}
    table{border-collapse:collapse;width:100%}
    td,th{border-bottom:1px solid var(--line);padding:8px;text-align:left;font-size:13px}
    th{color:var(--muted);font-weight:600;background:rgba(255,255,255,.02)}
    .mono{font-family:var(--mono)}
    details.section{margin:14px 0;border-radius:var(--radius);overflow:hidden}
    details.section>summary{list-style:none;cursor:pointer;display:flex;align-items:center;gap:10px;padding:12px 14px;background:var(--bg-2);border:1px solid var(--line);border-radius:var(--radius);user-select:none}
    details.section>summary:hover{background:#121a29}
    details.section[open]>summary{border-bottom-left-radius:0;border-bottom-right-radius:0}
    .summary-title{font-weight:600}
    .chev{transition:transform .18s ease;color:var(--muted)}
    details[open] .chev{transform:rotate(90deg)}
    .panel{padding:14px;border:1px solid var(--line);border-top:none;background:var(--bg-3)}
    #status{max-height:220px;overflow:auto;padding:12px;margin:0;background:#0a0f19;border-top:1px solid var(--line)}
    footer{color:var(--muted);font-size:12px;text-align:center;margin:18px 0}
    .spacer{flex:1}
    /* Gauges */
    .gauge svg{width:100%;height:120px;display:block}
    .gauge .arc{fill:none;stroke:#223049;stroke-width:10}
    .gauge .arc-active{fill:none;stroke:#2e86fd;stroke-width:10}
    .gauge .tick{stroke:#3a4a66;stroke-width:1}
    .gauge .needle{stroke:#4ea1ff;stroke-width:2}
    .gauge .hub{fill:#4ea1ff}
    .gauge .label{font:10px var(--sans);fill:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="row">
        <div class="title">Gauge BLE Web UI <span id="ver" style="font-size:12px;color:var(--muted);margin-left:6px"></span></div>
        <span id="connState" class="pill">Disconnected</span>
      </div>
      <div class="row">
        <button id="btnConnect" class="primary">Connect</button>
        <button id="btnDisconnect" class="ghost" disabled>Disconnect</button>
      </div>
    </div>
  </header>

  <main>
    <details class="section" open>
      <summary><span class="chev">&gt;</span><span class="summary-title">Dashboard</span><span class="spacer"></span><span class="pill">Live</span></summary>
      <div class="panel">
        <div class="grid">
          <div class="card" style="padding:14px">
            <div style="font-size:12px;color:var(--muted);margin-bottom:6px">RPM</div>
            <div id="tileRpm" style="font-size:36px;font-weight:800">--</div>
            <div class="gauge">
              <svg viewBox="0 0 100 60" aria-label="RPM gauge">
                <path class="arc" d="M5 50 A45 45 0 0 1 95 50"/>
                <g id="rpmTicks">
                  <line x1="10" y1="50" x2="10" y2="46" class="tick"/>
                  <line x1="30" y1="50" x2="30" y2="46" class="tick"/>
                  <line x1="50" y1="50" x2="50" y2="46" class="tick"/>
                  <line x1="70" y1="50" x2="70" y2="46" class="tick"/>
                  <line x1="90" y1="50" x2="90" y2="46" class="tick"/>
                </g>
                <g id="rpmNeedle" transform="rotate(-90 50 50)">
                  <line x1="50" y1="50" x2="50" y2="8" class="needle"/>
                </g>
                <circle cx="50" cy="50" r="3" class="hub"/>
                <text x="50" y="58" text-anchor="middle" class="label">0 - 8k</text>
              </svg>
            </div>
          </div>
          <div class="card" style="padding:14px">
            <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Speed</div>
            <div id="tileSpeed" style="font-size:36px;font-weight:800">--</div>
            <div class="gauge">
              <svg viewBox="0 0 100 60" aria-label="Speed gauge">
                <path class="arc" d="M5 50 A45 45 0 0 1 95 50"/>
                <g id="speedTicks">
                  <line x1="10" y1="50" x2="10" y2="46" class="tick"/>
                  <line x1="30" y1="50" x2="30" y2="46" class="tick"/>
                  <line x1="50" y1="50" x2="50" y2="46" class="tick"/>
                  <line x1="70" y1="50" x2="70" y2="46" class="tick"/>
                  <line x1="90" y1="50" x2="90" y2="46" class="tick"/>
                </g>
                <g id="speedNeedle" transform="rotate(-90 50 50)">
                  <line x1="50" y1="50" x2="50" y2="8" class="needle"/>
                </g>
                <circle cx="50" cy="50" r="3" class="hub"/>
                <text x="50" y="58" text-anchor="middle" class="label">0 - 160</text>
              </svg>
            </div>
          </div>
          <div class="card" style="padding:14px">
            <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Loop (ms)</div>
            <div id="tileLoop" style="font-size:24px;font-weight:700">--</div>
            <div id="tileWorst" style="font-size:12px;color:var(--muted)">Worst: --</div>
          </div>
        </div>
      </div>
    </details>

    <details class="section" open>
      <summary><span class="chev">&gt;</span><span class="summary-title">Connection & UUIDs</span><span class="spacer"></span><span class="pill">Setup</span></summary>
      <div class="panel">
        <div class="grid">
          <div>
            <label>Device filter (name prefix)</label>
            <input id="namePrefix" type="text" placeholder="e.g., 3000GT" />
          </div>
          <div>
            <label>Custom Service UUID (optional)</label>
            <input id="svcUuid" type="text" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
          </div>
          <div>
            <label>Commands Char UUID (write)</label>
            <input id="cmdUuid" type="text" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
          </div>
          <div>
            <label>BTBuffer Char UUID (notify)</label>
            <input id="bufUuid" type="text" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
          </div>
          <div>
            <label>OTA Control Char UUID (write)</label>
            <input id="otaUuid" type="text" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" />
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnSaveCfg">Save</button>
          <button id="btnLoadCfg" class="ghost">Load</button>
          <button id="btnClearCfg" class="ghost">Clear</button>
        </div>
      </div>
    </details>

    <details class="section" open>
      <summary><span class="chev">&gt;</span><span class="summary-title">Commands</span><span class="spacer"></span><span class="pill">Write</span></summary>
      <div class="panel">
        <div class="row" style="margin-bottom:10px">
      <label style="min-width:160px">Command encoding</label>
      <select id="cmdEncoding">
        <option value="ascii">ASCII (U/D/L/R/E/B)</option>
        <option value="enum" selected>Enum (0,1,2,3,4,255)</option>
      </select>
    </div>
        <div class="row" style="margin-bottom:10px">
      <button data-cmd="LEFT">&lt; Left</button>
          <button data-cmd="RIGHT">Right &gt;</button>
          <button data-cmd="UP">Up</button>
          <button data-cmd="DOWN">Down</button>
          <button data-cmd="ENTER">Enter</button>
          <button data-cmd="BACK">Back</button>
        </div>
        <div class="row">
          <input id="rawHex" type="text" placeholder="raw hex, e.g. A5 01 02 03"/>
          <button id="btnSendRaw">Send Raw</button>
        </div>
      </div>
    </details>

    <details class="section" open>
      <summary><span class="chev">&gt;</span><span class="summary-title">ECU Stream (BTBuffer)</span><span class="spacer"></span><span class="pill">Notify</span></summary>
      <div class="panel">
        <div class="row" style="margin-bottom:10px">
          <button id="btnStartLog">Start Log</button>
          <button id="btnStopLog" disabled>Stop Log</button>
          <button id="btnDownload" disabled>Download CSV</button>
        </div>
        <div class="card">
          <table>
            <thead><tr><th style="width:180px">Time</th><th>Payload (hex)</th><th>Parsed</th></tr></thead>
            <tbody id="tblBody"></tbody>
          </table>
        </div>
      </div>
    </details>

    <details class="section">
      <summary><span class="chev">&gt;</span><span class="summary-title">OTA</span><span class="spacer"></span><span class="pill">Reboot + Upload</span></summary>
      <div class="panel">
        <div class="row" style="margin-bottom:10px">
          <button id="btnOta" style="border-color:var(--warn)">Reboot to OTA</button>
          <span style="font-size:12px;color:var(--muted)">Writes magic then reboots into OTA loader</span>
        </div>
        <div class="card" style="padding:12px;display:grid;gap:10px">
          <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px">
            <div>
              <label>OTA Service UUID</label>
              <input id="otaSvcUuid" type="text" placeholder="service UUID"/>
            </div>
            <div>
              <label>Base Addr Char UUID</label>
              <input id="otaBaseUuid" type="text" placeholder="base address char UUID"/>
            </div>
            <div>
              <label>Raw Data Char UUID</label>
              <input id="otaDataUuid" type="text" placeholder="raw data char UUID"/>
            </div>
            <div>
              <label>Config Char UUID</label>
              <input id="otaConfUuid" type="text" placeholder="config char UUID"/>
            </div>
            <div>
              <label>Event Char UUID</label>
              <input id="otaEvtUuid" type="text" placeholder="event/indicate char UUID"/>
            </div>
            <div>
              <label>App Base Offset (hex, 3 bytes)</label>
              <input id="otaBaseAddr" type="text" placeholder="0007000"/>
            </div>
            <div>
              <label>Chunk size (bytes)</label>
              <input id="otaChunk" type="text" placeholder="244"/>
            </div>
            <div>
              <label>Number of sectors</label>
              <input id="otaNumSectors" type="text" placeholder="0"/>
            </div>
            <div>
              <label>Chunk delay (ms)</label>
              <input id="otaChunkDelay" type="text" placeholder="0"/>
            </div>
          </div>
          <div class="row" style="align-items:center;gap:10px;flex-wrap:wrap">
            <input id="otaFile" type="file" accept=".bin" style="color:var(--muted)"/>
            <button id="btnOtaUpload">Start OTA Upload</button>
            <button id="btnOtaCancel" class="ghost" disabled>Cancel</button>
            <span id="otaStatusTxt" class="pill" style="background:var(--pill);border-color:var(--line)">Idle</span>
          </div>
          <div style="font-size:12px;color:var(--muted)">After the device reboots into OTA mode, connect again and start the upload.</div>
        </div>
      </div>
    </details>

    <details class="section" open>
      <summary><span class="chev">&gt;</span><span class="summary-title">Status</span><span class="spacer"></span><span class="pill">Debug</span></summary>
      <div class="panel">
        <pre id="status" class="mono"></pre>
      </div>
    </details>

    <footer>Tip: this UI works best on HTTPS or <span class="mono">localhost</span>.</footer>
  </main>

<script>
(function(){
  'use strict';
  var UI_VERSION = 'v0.6.4';

  // ===== Defaults & Known Services =====
  var Defaults = {
    namePrefix: '',
    SERVICE_UUID: '',
    CMD_CHAR_UUID: '00000001-8e22-4541-9d4c-21edae82ed19',
    BTBUF_CHAR_UUID: '00000003-8e22-4541-9d4c-21edae82ed19',
    OTA_CHAR_UUID: '0000fe11-8e22-4541-9d4c-21edae82ed19'
  };
  var KNOWN_SERVICES = [
    '00000000-cc7a-482a-984a-7f2ed5b3e58f', // UserButtonService (commands)
    '00000002-cc7a-482a-984a-7f2ed5b3e58f', // ClientReadService (BTBuffer/READNEXT)
    '00000a00-cc7a-482a-984a-7f2ed5b3e58f'  // RebootReqService (OTA reboot)
  ];

  // ===== Command Encoding =====
  var CommandMapEnum  = { LEFT:[3], RIGHT:[4], UP:[1], DOWN:[2], ENTER:[0], BACK:[255] };
  var CommandMapASCII = { LEFT:[0x4C], RIGHT:[0x52], UP:[0x55], DOWN:[0x44], ENTER:[0x45], BACK:[0x42] };
  function getCmdMap(){ var sel=document.querySelector('#cmdEncoding'); var mode=sel?sel.value:'ascii'; return mode==='enum'?CommandMapEnum:CommandMapASCII; }

  // ===== OTA magic =====
  // OTA reboot payload: [reboot_flag, start_sector_idx, num_sectors] per CubeWB BLE_Ota app_conf
  // 0x01 = reboot into BLE OTA app, sector index defaults to 7, num_sectors left 0
  var OTA_MAGIC = [0x01, 0x07, 0x00];
  var OTA_UPLOAD_DEFAULTS = {
    // STM32WB OTA loader service/characteristics
    svc: '0000fe20-cc7a-482a-984a-7f2ed5b3e58f',
    base: '0000fe22-8e22-4541-9d4c-21edae82ed19',
    conf: '0000fe23-8e22-4541-9d4c-21edae82ed19',
    data: '0000fe24-8e22-4541-9d4c-21edae82ed19',
    evt:  '0000fe25-8e22-4541-9d4c-21edae82ed19', // not used in legacy loader, keep placeholder
    appBase: '0007000',                               // 3-byte offset (0x007000) for app slot
    chunkSize: 244,
    numSectors: 0,                                    // if 0, auto-calc from bin size
    chunkDelayMs: 0
  };

  // ===== Frame reassembly =====
  var USE_LENGTH_PREFIX = false; // notifications already arrive as full frames
  var LENGTH_BYTES = 2;         // u16 little-endian (unused when above is false)
  var DELIM = 0x0A;             // for ASCII mode (unused here)

  // ===== Helpers =====
  function $(s){ return document.querySelector(s); }
  function log(msg){ var el=$('#status'); if(!el) return; el.textContent += String(msg)+'\n'; el.scrollTop = el.scrollHeight; }
  function setState(txt){ var pill=$('#connState'); if(pill) pill.textContent = txt; }
  function hex(u8){ var out=[],i; for(i=0;i<u8.length;i++){ var s=u8[i].toString(16); if(s.length<2) s='0'+s; out.push(s);} return out.join(' '); }
  function toBytes(hexStr){ var bytes=[]; String(hexStr).replace(/[^0-9a-fA-F]/g,'').replace(/(..)/g,function(m,b){ bytes.push(parseInt(b,16)); }); return new Uint8Array(bytes); }
  function le16(b0,b1){ return (b0 | (b1<<8)); }
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function setNeedle(id,value,min,max){ var el=document.getElementById(id); if(!el) return; var span=max-min; if(span<=0) return; var v=clamp(value,min,max); var pct=(v-min)/span; var angle=-90 + pct*180; el.setAttribute('transform','rotate('+angle+' 50 50)'); }
  function propsStr(ch){ if(!ch||!ch.properties) return 'none'; var p=ch.properties,a=[]; if(p.read)a.push('read'); if(p.write)a.push('write'); if(p.writeWithoutResponse)a.push('wwr'); if(p.notify)a.push('notify'); if(p.indicate)a.push('indicate'); return a.join('|')||'none'; }
  async function ensureNotifications(ch,label){
    if(!ch) return false;
    if(!(ch.properties && (ch.properties.indicate || ch.properties.notify))) return false;
    try{
      await ch.startNotifications();
      log(label+' notifications enabled');
      return true;
    }catch(err){
      log(label+' notify error: '+err.message);
      return false;
    }
  }

  // ===== Persist inputs =====
  var KEYS = ['namePrefix','svcUuid','cmdUuid','bufUuid','otaUuid'];
  function saveCfg(){ var cfg={}; for(var i=0;i<KEYS.length;i++){ var k=KEYS[i]; var el=$('#'+k); if(el) cfg[k]=el.value; } localStorage.setItem('gauge-ble-ui', JSON.stringify(cfg)); log('Config saved'); }
  function loadCfg(){ var s=localStorage.getItem('gauge-ble-ui'); if(!s) return; var cfg=JSON.parse(s); for(var i=0;i<KEYS.length;i++){ var k=KEYS[i]; var el=$('#'+k); if(el && cfg[k]!==undefined) el.value=cfg[k]; } log('Config loaded'); }
  function clearCfg(){
    try {
      localStorage.removeItem('gauge-ble-ui');
      log('Config cleared');
    } catch(e) {
      log(e.message);
    }
    applyDefaults();
  }
  function applyDefaults(){
    var had = !!localStorage.getItem('gauge-ble-ui');
    if(!had){
      var np=$('#namePrefix'); if(np) np.value=Defaults.namePrefix;
      var su=$('#svcUuid');    if(su) su.value=Defaults.SERVICE_UUID;
      var cu=$('#cmdUuid');    if(cu) cu.value=Defaults.CMD_CHAR_UUID;
      var bu=$('#bufUuid');    if(bu) bu.value=Defaults.BTBUF_CHAR_UUID;
      var ou=$('#otaUuid');    if(ou) ou.value=Defaults.OTA_CHAR_UUID;
      // OTA upload defaults
      $('#otaSvcUuid') && ($('#otaSvcUuid').value = OTA_UPLOAD_DEFAULTS.svc);
      $('#otaBaseUuid') && ($('#otaBaseUuid').value = OTA_UPLOAD_DEFAULTS.base);
      $('#otaDataUuid') && ($('#otaDataUuid').value = OTA_UPLOAD_DEFAULTS.data);
      $('#otaConfUuid') && ($('#otaConfUuid').value = OTA_UPLOAD_DEFAULTS.conf);
      $('#otaEvtUuid') && ($('#otaEvtUuid').value = OTA_UPLOAD_DEFAULTS.evt);
      $('#otaBaseAddr') && ($('#otaBaseAddr').value = OTA_UPLOAD_DEFAULTS.appBase);
      $('#otaChunk') && ($('#otaChunk').value = OTA_UPLOAD_DEFAULTS.chunkSize);
      $('#otaNumSectors') && ($('#otaNumSectors').value = OTA_UPLOAD_DEFAULTS.numSectors);
      $('#otaChunkDelay') && ($('#otaChunkDelay').value = OTA_UPLOAD_DEFAULTS.chunkDelayMs);
      return;
    }
    // If config exists, load it then fill any missing/blank fields from Defaults
    loadCfg();
    var map = {
      namePrefix: Defaults.namePrefix,
      svcUuid:    Defaults.SERVICE_UUID,
      cmdUuid:    Defaults.CMD_CHAR_UUID,
      bufUuid:    Defaults.BTBUF_CHAR_UUID,
      otaUuid:    Defaults.OTA_CHAR_UUID
    };
    ['namePrefix','svcUuid','cmdUuid','bufUuid','otaUuid'].forEach(function(k){
      var el = $('#'+k); if(!el) return; var v = (el.value||'').trim(); if(!v) el.value = map[k] || '';
    });
  }

  function getOtaCfg(){
    function val(id, def){ var el=$(id); var v=el && el.value ? el.value.trim() : ''; return v || def || ''; }
    var cfg={
      svc: val('#otaSvcUuid', OTA_UPLOAD_DEFAULTS.svc),
      base: val('#otaBaseUuid', OTA_UPLOAD_DEFAULTS.base),
      data: val('#otaDataUuid', OTA_UPLOAD_DEFAULTS.data),
      conf: val('#otaConfUuid', OTA_UPLOAD_DEFAULTS.conf),
      evt: val('#otaEvtUuid', OTA_UPLOAD_DEFAULTS.evt),
      baseAddr: val('#otaBaseAddr', OTA_UPLOAD_DEFAULTS.appBase),
      chunkSize: parseInt(val('#otaChunk', OTA_UPLOAD_DEFAULTS.chunkSize),10) || OTA_UPLOAD_DEFAULTS.chunkSize,
      numSectors: parseInt(val('#otaNumSectors', OTA_UPLOAD_DEFAULTS.numSectors),10) || OTA_UPLOAD_DEFAULTS.numSectors,
      chunkDelayMs: parseInt(val('#otaChunkDelay', OTA_UPLOAD_DEFAULTS.chunkDelayMs),10) || OTA_UPLOAD_DEFAULTS.chunkDelayMs
    };
    return cfg;
  }

  // ===== Reassembler =====
  function Reassembler(){ this.buf=new Uint8Array(0); }
  Reassembler.prototype.push = function(chunk){
    var combined=new Uint8Array(this.buf.length+chunk.length); combined.set(this.buf,0); combined.set(chunk,this.buf.length); this.buf=combined;
    var frames=[];
    if(USE_LENGTH_PREFIX){
      while(this.buf.length>=LENGTH_BYTES){
        var len=le16(this.buf[0],this.buf[1]);
        if(this.buf.length < LENGTH_BYTES+len) break;
        frames.push(this.buf.slice(LENGTH_BYTES,LENGTH_BYTES+len));
        this.buf=this.buf.slice(LENGTH_BYTES+len);
      }
    } else {
      // Each notification is already a complete frame
      frames.push(this.buf);
      this.buf=new Uint8Array(0);
    }
    return frames;
  };
  Reassembler.prototype.reset = function(){ this.buf=new Uint8Array(0); };

  // ===== Decoder =====
  function decodeFrame(payload){
    var dv=new DataView(payload.buffer,payload.byteOffset,payload.byteLength);
    if(payload.byteLength<8) return {len:payload.length};
    var id1=dv.getUint16(0,true); var id2=dv.getUint16(2,true); if(id2===0xFFFF) id2=-1; var tick=dv.getUint32(4,true);
    var words=[]; for(var off=8; off+4<=payload.byteLength; off+=4){ words.push(dv.getUint32(off,true)); }
    var obj={id1:id1,id2:id2,tick:tick,wordsCount:words.length};
    if(id1===0 && id2===0 && words.length>=6){ obj.loopCnt=words[0]; obj.loopPeriod_ms=words[1]; obj.worstLoop_ms=words[2]; obj.speed=words[4]; obj.rpm=words[5]; }
    if(id1===1 && id2===-1 && words.length>=1){ obj.ecu_req=words[0]; }
    if(typeof obj.rpm==='number'){ var tr=$('#tileRpm'); if(tr) tr.textContent=String(obj.rpm); setNeedle('rpmNeedle', obj.rpm, 0, 8000); }
    if(typeof obj.speed==='number'){ var ts=$('#tileSpeed'); if(ts) ts.textContent=String(obj.speed); setNeedle('speedNeedle', obj.speed, 0, 160); }
    if(typeof obj.loopPeriod_ms==='number'){ var tl=$('#tileLoop'); if(tl) tl.textContent=String(obj.loopPeriod_ms); var tw=$('#tileWorst'); if(tw && typeof obj.worstLoop_ms==='number') tw.textContent='Worst: '+obj.worstLoop_ms; }
    return obj;
  }

  // ===== OTA upload helpers =====
  function setOtaStatus(txt){ var el=$('#otaStatusTxt'); if(el) el.textContent=txt; log('OTA: '+txt); }

  async function writeChar(ch,u8,forceResp){
    if(!ch) throw new Error('characteristic missing');
    var props=ch.properties||{};
    if(forceResp && props.write){ return ch.writeValue(u8); }
    if(!forceResp && props.writeWithoutResponse){ return ch.writeValueWithoutResponse(u8); }
    if(props.write){ return ch.writeValue(u8); }
    return ch.writeValue(u8);
  }

  async function discoverOta(){
    var cfg=getOtaCfg();
    state.ota={svc:cfg.svc,base:null,data:null,conf:null,evt:null};
    if(!cfg.svc) return;
    try{
      state.ota.base = await findCharacteristic(state.server, cfg.base, cfg.svc);
      state.ota.data = await findCharacteristic(state.server, cfg.data, cfg.svc);
      state.ota.conf = await findCharacteristic(state.server, cfg.conf, cfg.svc);
      state.ota.evt  = await findCharacteristic(state.server, cfg.evt,  cfg.svc);
      log('OTA service: '+(cfg.svc||'(none)'));
      ['base','data','conf','evt'].forEach(function(k){
        var ch=state.ota[k];
        log(' OTA '+k+': '+(ch ? (ch.uuid + ' ['+propsStr(ch)+']') : 'NOT FOUND'));
      });
      // Subscribe to OTA conf/event indications if present
      var confOk = await ensureNotifications(state.ota.conf,'OTA conf');
      if(confOk){
        state.ota.conf.addEventListener('characteristicvaluechanged', function(ev){
          var v=new Uint8Array(ev.target.value.buffer,ev.target.value.byteOffset,ev.target.value.byteLength);
          log('OTA conf event: '+hex(v));
          if(state.otaUpload.confResolve){ state.otaUpload.confResolve(); state.otaUpload.confResolve=null; }
        });
      } else {
        log('OTA conf notifications NOT enabled; conf indications may be missed');
      }
      var evtOk = await ensureNotifications(state.ota.evt,'OTA evt');
      if(evtOk){
        state.ota.evt.addEventListener('characteristicvaluechanged', function(ev){
          var v=new Uint8Array(ev.target.value.buffer,ev.target.value.byteOffset,ev.target.value.byteLength);
          log('OTA event: '+hex(v));
        });
      }
    }catch(err){
      log('OTA discovery error: '+err.message);
    }
  }

  async function otaUpload(){
    var cfg=getOtaCfg();
    if(!state.device || !state.server){ return log('Connect to device in OTA mode first'); }
    if(!state.ota.base || !state.ota.data || !state.ota.conf){ await discoverOta(); }
    if(!state.ota.base || !state.ota.data || !state.ota.conf) return log('OTA characteristics not found');
    var fileEl=$('#otaFile'); if(!fileEl || !fileEl.files || !fileEl.files.length) return log('Select a firmware file first');
    var file=fileEl.files[0];
    setOtaStatus('Reading '+file.name+'...');
    var buf=await file.arrayBuffer();
    var bin=new Uint8Array(buf);
    var chunkSize=Math.max(20, Math.min(248, cfg.chunkSize||OTA_UPLOAD_DEFAULTS.chunkSize));
    var baseAddr=parseInt(cfg.baseAddr,16); if(isNaN(baseAddr)) baseAddr=0x0007000;
    baseAddr = baseAddr & 0xFFFFFF; // 3-byte offset expected
    var startSector = Math.floor(baseAddr / 4096); // derive from offset (4KB pages)
    var pageSize = 4096;
    var autoSectors = Math.ceil(bin.length / pageSize);
    var numSectors = (cfg.numSectors && cfg.numSectors>0) ? cfg.numSectors : autoSectors;
    setOtaStatus('Computed sectors: '+numSectors+' (bin '+bin.length+' bytes)');
    state.otaUpload.cancel=false;
    $('#btnOtaUpload') && ($('#btnOtaUpload').disabled=true);
    $('#btnOtaCancel') && ($('#btnOtaCancel').disabled=false);
    try{
      // write base address command: [cmd, addr0, addr1, addr2]
      var baseU8=new Uint8Array(4);
      baseU8[0]=0x02; // application upload
      baseU8[1]= baseAddr & 0xFF;
      baseU8[2]= (baseAddr>>8) & 0xFF;
      baseU8[3]= (baseAddr>>16) & 0xFF;
      setOtaStatus('Setting base addr 0x'+baseAddr.toString(16)+' (cmd 0x02)');
      await writeChar(state.ota.base, baseU8, true); // force write with response
      setOtaStatus('Base addr set 0x'+baseAddr.toString(16));
      setOtaStatus('Upload started ('+bin.length+' bytes, chunk '+chunkSize+')');
      for(var off=0; off<bin.length; off+=chunkSize){
        if(state.otaUpload.cancel) throw new Error('Cancelled');
        var slice=bin.slice(off, Math.min(off+chunkSize, bin.length));
        await writeChar(state.ota.data, slice, false);
        if(cfg.chunkDelayMs>0) await new Promise(function(res){ setTimeout(res, cfg.chunkDelayMs); });
        if((off/chunkSize)%25===0) setOtaStatus('Sending... '+Math.min(bin.length, off+chunkSize)+' / '+bin.length);
      }
      // upload finished command (with sectors)
      var fin1=new Uint8Array([0x07, startSector & 0xFF, numSectors & 0xFF, 0x00]);
      await writeChar(state.ota.base, fin1, true);
      setOtaStatus('Finish command sent (1)');
      await new Promise(function(res){ setTimeout(res, 50); });
      await writeChar(state.ota.base, fin1, true);
      setOtaStatus('Finish command sent (2)');
      setOtaStatus('Upload finished, waiting for reboot/indication');
      // wait for conf indication or timeout
      var waited=false;
      var timeoutId=null;
      var waitConf = new Promise(function(resolve){
        state.otaUpload.confResolve = function(){
          if(timeoutId){ clearTimeout(timeoutId); timeoutId=null; }
          resolve();
        };
        timeoutId = setTimeout(function(){ waited=true; resolve(); }, 20000);
      });
      await waitConf;
      state.otaUpload.confResolve = null;
      if(waited){ setOtaStatus('No conf indication within timeout; check device'); }
      else {
        setOtaStatus('Conf indication received; waiting for reboot');
        await new Promise(function(res){ setTimeout(res, 1000); });
      }
      // optional: leave connection open; user can disconnect manually
    }catch(err){
      setOtaStatus('Error: '+err.message);
    }finally{
      $('#btnOtaUpload') && ($('#btnOtaUpload').disabled=false);
      $('#btnOtaCancel') && ($('#btnOtaCancel').disabled=true);
    }
  }


  // ===== BLE session =====
  var state={
    device:null,
    server:null,
    reasm:new Reassembler(),
    chars:{cmd:null,buf:null,ota:null},
    ota:{svc:null,base:null,data:null,conf:null,evt:null},
    logging:false,
    logRows:[],
    otaUpload:{file:null,cancel:false,confResolve:null}
  };

  function findCharacteristic(server, charUuid, svcUuid){
    if(!charUuid) return Promise.resolve(null);
    return new Promise(function(resolve){
      (async function(){
        try{
          if(svcUuid){
            try{
              var svc=await server.getPrimaryService(svcUuid);
              var ch=await svc.getCharacteristic(charUuid);
              if(ch) return resolve(ch);
            }catch(err){ log('Find char error: '+err.message); }
          }
          var services=await server.getPrimaryServices();
          for(var i=0;i<services.length;i++){
            try{ var ch2=await services[i].getCharacteristic(charUuid); if(ch2){ return resolve(ch2); } }catch(_e){}
          }
          log('Find char error: No Services matching UUID '+svcUuid+' found in Device.');
        }catch(err){ log('Find char error: '+err.message); }
        resolve(null);
      })();
    });
  }

  async function connect(){
    var statusEl=$('#status'); if(statusEl) statusEl.textContent='';
    log('Connect clicked');
    if(!('bluetooth' in navigator)){ log('Web Bluetooth not supported. Use Chrome/Edge desktop or Chrome on Android over HTTPS.'); return; }
    if(!window.isSecureContext){ log('Warning: not HTTPS/localhost. Web Bluetooth may be blocked.'); }
    setState('Requesting...');

    var namePrefix=($('#namePrefix') && $('#namePrefix').value) ? $('#namePrefix').value : Defaults.namePrefix;
    var svcUuid=($('#svcUuid') && $('#svcUuid').value) ? $('#svcUuid').value : Defaults.SERVICE_UUID;
    var cmdCharUuid=($('#cmdUuid') && $('#cmdUuid').value) ? $('#cmdUuid').value : Defaults.CMD_CHAR_UUID;
    var bufCharUuid=($('#bufUuid') && $('#bufUuid').value) ? $('#bufUuid').value : Defaults.BTBUF_CHAR_UUID;
    var otaCharUuid=($('#otaUuid') && $('#otaUuid').value) ? $('#otaUuid').value : Defaults.OTA_CHAR_UUID;
    var otaSvcCfg=getOtaCfg();

    var options={optionalServices: KNOWN_SERVICES.slice()};
    if(namePrefix && namePrefix.trim().length){ options.filters=[{namePrefix:namePrefix.trim()}]; } else { options.acceptAllDevices=true; }
    if(svcUuid && options.optionalServices.indexOf(svcUuid)===-1) options.optionalServices.push(svcUuid);
    if(otaSvcCfg && otaSvcCfg.svc && options.optionalServices.indexOf(otaSvcCfg.svc)===-1) options.optionalServices.push(otaSvcCfg.svc);

    try{
      var device=await navigator.bluetooth.requestDevice(options);
      state.device=device; device.addEventListener('gattserverdisconnected', onDisconnect);
      setState('Connecting...');
      state.server=await device.gatt.connect();
      log('Connected to ' + (device.name||'(unnamed)'));

      state.chars.cmd = await findCharacteristic(state.server, cmdCharUuid, svcUuid);
      state.chars.buf = await findCharacteristic(state.server, bufCharUuid, svcUuid);
      state.chars.ota = await findCharacteristic(state.server, otaCharUuid, svcUuid);

      log('CMD char: ' + (state.chars.cmd ? (state.chars.cmd.uuid + ' [' + propsStr(state.chars.cmd) + ']') : 'NOT FOUND'));
      log('BUF char: ' + (state.chars.buf ? (state.chars.buf.uuid + ' [' + propsStr(state.chars.buf) + ']') : 'NOT FOUND'));
      log('OTA char: ' + (state.chars.ota ? (state.chars.ota.uuid + ' [' + propsStr(state.chars.ota) + ']') : 'NOT FOUND'));

      if(state.chars.buf){ await state.chars.buf.startNotifications(); state.chars.buf.addEventListener('characteristicvaluechanged', onNotify); }
      // Discover OTA upload chars (if present in loader)
      await discoverOta();
      try{
        var svcs=await state.server.getPrimaryServices();
        log('Services found: '+svcs.map(function(s){return s.uuid;}).join(', '));
      }catch(_e){}

      var btnDis=$('#btnDisconnect'); if(btnDis) btnDis.disabled=false; var btnCon=$('#btnConnect'); if(btnCon) btnCon.disabled=true; setState('Connected');
    }catch(err){ log('Connect error: ' + err.message); setState('Disconnected'); }
  }

  async function disconnect(){ try{ if(state.device && state.device.gatt && state.device.gatt.connected){ state.device.gatt.disconnect(); } }catch(_e){} }
  function onDisconnect(){ log('Disconnected'); var dis=$('#btnDisconnect'); if(dis) dis.disabled=true; var con=$('#btnConnect'); if(con) con.disabled=false; setState('Disconnected'); }

  function onNotify(ev){
    var dv=ev.target.value; var chunk=new Uint8Array(dv.buffer,dv.byteOffset,dv.byteLength);
    var frames=state.reasm.push(chunk);
    for(var i=0;i<frames.length;i++){
      var payload=frames[i]; var t=new Date().toISOString(); var parsed=decodeFrame(payload);
      appendRow(t,payload,parsed);
      if(state.logging){ state.logRows.push([t,hex(payload),JSON.stringify(parsed)]); }
    }
  }

  function appendRow(t,u8,parsed){
    var tr=document.createElement('tr');
    var td1=document.createElement('td'); td1.className='mono'; td1.textContent=t;
    var td2=document.createElement('td'); td2.className='mono'; td2.textContent=hex(u8);
    var td3=document.createElement('td'); td3.className='mono'; td3.textContent=JSON.stringify(parsed);
    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
    var tbody=$('#tblBody'); if(!tbody) return; tbody.prepend(tr); while(tbody.rows.length>300) tbody.deleteRow(-1);
  }

  async function sendCommand(kind){
    if(!state.chars.cmd) return log('No command characteristic');
    var map=getCmdMap(); var bytes=map[kind]; if(!bytes) return log('Unknown command '+kind);
    var u8=new Uint8Array(bytes); var props=state.chars.cmd && state.chars.cmd.properties; var mode=(document.querySelector('#cmdEncoding')||{value:'ascii'}).value;
    try{
      if(props && props.writeWithoutResponse){ await state.chars.cmd.writeValueWithoutResponse(u8); return log('Sent '+kind+' ('+mode+') via WWR: '+bytes.map(function(b){var s=b.toString(16);return (s.length<2?'0':'')+s;}).join(' ')); }
      if(props && props.write){ await state.chars.cmd.writeValue(u8); return log('Sent '+kind+' ('+mode+') via WRITE: '+bytes.map(function(b){var s=b.toString(16);return (s.length<2?'0':'')+s;}).join(' ')); }
      try{ await state.chars.cmd.writeValueWithoutResponse(u8); return log('Sent '+kind+' ('+mode+') via WWR (fallback)'); }
      catch(_e2){ await state.chars.cmd.writeValue(u8); return log('Sent '+kind+' ('+mode+') via WRITE (fallback)'); }
    }catch(err){ log('Send error ('+kind+'): '+err.message); }
  }

  async function sendRaw(){
    if(!state.chars.cmd) return log('No command characteristic');
    var text=$('#rawHex') && $('#rawHex').value ? $('#rawHex').value.trim() : ''; if(!text) return;
    try{
      var buf=toBytes(text); var CHUNK=20; for(var i=0;i<buf.length;i+=CHUNK){ await state.chars.cmd.writeValueWithoutResponse(buf.slice(i,Math.min(i+CHUNK,buf.length))); }
      log('Sent RAW: '+text);
    }catch(err){ log('Raw send error: '+err.message); }
  }

  async function doOta(){
    if(!state.chars.ota) return log('No OTA characteristic');
    if(!window.confirm('Reboot device into OTA firmware?')) return;
    try{
      var u8=new Uint8Array(OTA_MAGIC);
      var props=state.chars.ota && state.chars.ota.properties;
      if(props && props.writeWithoutResponse){ await state.chars.ota.writeValueWithoutResponse(u8); }
      else if(props && props.write){ await state.chars.ota.writeValue(u8); }
      else { await state.chars.ota.writeValueWithoutResponse(u8); }
      log('OTA reboot requested (magic '+OTA_MAGIC.map(function(b){var s=b.toString(16);return (s.length<2?'0':'')+s;}).join(' ')+')');
    }catch(err){ log('OTA write error: '+err.message); }
  }

  function startLog(){ state.logging=true; state.logRows=[]; var dl=$('#btnDownload'); if(dl) dl.disabled=true; var st=$('#btnStartLog'); if(st) st.disabled=true; var sp=$('#btnStopLog'); if(sp) sp.disabled=false; }
  function stopLog(){ state.logging=false; var sp=$('#btnStopLog'); if(sp) sp.disabled=true; var st=$('#btnStartLog'); if(st) st.disabled=false; var dl=$('#btnDownload'); if(dl && state.logRows.length) dl.disabled=false; }
  function download(){ var rows=[["time","payload_hex","parsed_json"]].concat(state.logRows); var csv=rows.map(function(r){ return r.map(function(x){ var s=String(x).replace(/\"/g,'""'); return '"'+s+'"'; }).join(','); }).join('\n'); var blob=new Blob([csv],{type:'text/csv'}); var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='ecu_log_'+Date.now()+'.csv'; a.click(); setTimeout(function(){ URL.revokeObjectURL(url); },1000); }

  function setupAccordion(){ var all=document.querySelectorAll('details.section'); for(var i=0;i<all.length;i++){ (function(d){ d.addEventListener('toggle', function(){ if(d.open){ for(var j=0;j<all.length;j++){ if(all[j]!==d) all[j].open=false; } } }); })(all[i]); } }

  function wireHandlers(){
    function wire(sel,fn){ var el=$(sel); if(!el){ log('Missing element '+sel); return false;} el.addEventListener('click',fn); return true; }
    var ok = true;
    ok = wire('#btnConnect',connect) && ok;
    ok = wire('#btnDisconnect',disconnect) && ok;
    var cmdBtns = document.querySelectorAll('[data-cmd]');
    for(var i=0;i<cmdBtns.length;i++){ (function(btn){ btn.addEventListener('click', function(){ sendCommand(btn.getAttribute('data-cmd')); }); })(cmdBtns[i]); }
    ok = wire('#btnSendRaw',sendRaw) && ok;
    ok = wire('#btnOta',doOta) && ok;
    ok = wire('#btnStartLog',startLog) && ok;
    ok = wire('#btnStopLog',stopLog) && ok;
    ok = wire('#btnDownload',download) && ok;
    ok = wire('#btnOtaUpload', function(){ otaUpload(); }) && ok;
    ok = wire('#btnOtaCancel', function(){ state.otaUpload.cancel=true; setOtaStatus('Cancelling...'); }) && ok;
    ok = wire('#btnSaveCfg',saveCfg) && ok;
    ok = wire('#btnLoadCfg',loadCfg) && ok;
    ok = wire('#btnClearCfg',clearCfg) && ok;
    log('Event handlers attached' + (ok?'':' (some missing)'));
  }

  // ===== Boot =====
  (function boot(){
    var ver=$('#ver'); if(ver) ver.textContent=UI_VERSION;
    applyDefaults();
    wireHandlers();
    setupAccordion();
    if(!('bluetooth' in navigator)) log('Web Bluetooth not detected. Try Chrome/Edge desktop or Chrome on Android.');
    log('UI loaded');
    log('Defaults in use: CMD='+(Defaults.CMD_CHAR_UUID||'-')+' BUF='+(Defaults.BTBUF_CHAR_UUID||'-')+' OTA='+(Defaults.OTA_CHAR_UUID||'-'));
  })();

  // ===== Error hooks & Status panel =====
  window.addEventListener('error', function(e){ log('Script error: ' + (e && (e.message||e.error) || 'unknown')); });
  window.addEventListener('unhandledrejection', function(e){ var r=e && e.reason; log('Unhandled promise: ' + (r && (r.message||r) || 'unknown')); });
})();
</script>
</body>
</html>

