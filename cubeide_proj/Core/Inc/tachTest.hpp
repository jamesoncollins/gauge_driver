#pragma once
#include <stdint.h>
#include <math.h>

// LPTIM2 handle is generated by CubeMX
#ifdef __cplusplus
extern "C" {
#endif
extern LPTIM_HandleTypeDef hlptim2;
#ifdef __cplusplus
}
#endif

// Kernel clock for LPTIM2 after prescaler (e.g. 64 MHz / 64 = 1 MHz)
#ifndef LPTIM2_KCLK_HZ
#define LPTIM2_KCLK_HZ 500000UL
#endif

// Below this frequency we stop generating pulses and park the output.
#ifndef TACHTEST_MIN_HZ
#define TACHTEST_MIN_HZ 0.10f   // treat <0.1 Hz as "0 Hz"
#endif

// If non-zero, park HIGH instead of LOW when "0 Hz".
#ifndef TACHTEST_PARK_HIGH
#define TACHTEST_PARK_HIGH 0
#endif

// GPIO used for the tach output when parked (DC state)
#ifndef TACHTEST_GPIO_PORT
#define TACHTEST_GPIO_PORT GPIOA        // adjust to your board
#endif

#ifndef TACHTEST_GPIO_PIN
#define TACHTEST_GPIO_PIN GPIO_PIN_8    // PA8 in your case
#endif

static float current_cmd_val = 0.0f;
static uint8_t s_parked = 0;    // 0 = PWM running, 1 = parked DC

// Initialize LPTIM2 PWM on PA8 and start in a safe, low frequency
static inline void TachTest_Init(void)
{
    const uint32_t fclk = (uint32_t)LPTIM2_KCLK_HZ;
    uint32_t period_ticks = fclk / 10U;   // 10 Hz to start

    if (period_ticks < 2U)       period_ticks = 2U;
    if (period_ticks > 65535U)   period_ticks = 65535U;

    uint32_t cmp = (period_ticks - 1U) >> 1; // ~50% duty

    // Start PWM on LPTIM2 CH1
    HAL_LPTIM_PWM_Start(&hlptim2, period_ticks - 1U, cmp);
    s_parked = 0;
}

// Stop PWM if you need to relinquish the pin
static inline void TachTest_Stop(void)
{
    HAL_LPTIM_PWM_Stop(&hlptim2);
    s_parked = 1;
}

// Set raw frequency in Hz; updates ARR/CMP or parks the pin for very low Hz.
static inline void TachTest_SetHz(float hz)
{
    current_cmd_val = hz;
    const uint32_t fclk = (uint32_t)LPTIM2_KCLK_HZ;

    // ----- Parked / "0 Hz" region -----
    if (hz <= TACHTEST_MIN_HZ) {
        if (!s_parked) {
            // Stop PWM so PA8 goes back to GPIO control
            HAL_LPTIM_PWM_Stop(&hlptim2);
            s_parked = 1;
        }

        // Drive pin as DC value
#if TACHTEST_PARK_HIGH
        HAL_GPIO_WritePin(TACHTEST_GPIO_PORT, TACHTEST_GPIO_PIN, GPIO_PIN_SET);
#else
        HAL_GPIO_WritePin(TACHTEST_GPIO_PORT, TACHTEST_GPIO_PIN, GPIO_PIN_RESET);
#endif
        return;
    }

    // ----- Normal PWM region -----
    // If we were parked, restart PWM
    if (s_parked) {
        // Make sure pin is in AF mode for LPTIM2_CH1 (should already be from MX init)
        // Compute an initial period for the restart; will be overwritten below.
        uint32_t init_period_ticks = fclk / 10U;
        if (init_period_ticks < 2U)       init_period_ticks = 2U;
        if (init_period_ticks > 65535U)   init_period_ticks = 65535U;

        uint32_t init_cmp = (init_period_ticks - 1U) >> 1;
        HAL_LPTIM_PWM_Start(&hlptim2, init_period_ticks - 1U, init_cmp);
        s_parked = 0;
    }

    // Compute period from frequency; clamp to 16-bit
    float period_f = (float)fclk / hz;
    uint32_t period;
    if (period_f < 2.f) {
        period = 2U;
    } else if (period_f > 65535.f) {
        period = 65535U;
    } else {
        period = (uint32_t)(period_f + 0.5f); // rounded
    }

    // 50% duty
    uint32_t cmp = (period - 1U) >> 1;

    // Live update (no stop/start)
    __HAL_LPTIM_AUTORELOAD_SET(&hlptim2, period - 1U);
    __HAL_LPTIM_COMPARE_SET(&hlptim2, cmp);
}

static inline float TachTest_getCurrentCmd(void)
{
    return current_cmd_val;
}
