
#include "main.h"
#include "usb_device.h"

#include "usbd_cdc_if.h"
extern "C" {
#include "../Core/MCP4725-lib/MCP4725.h"
#include "../Core/BMI088-lib/BMI088.h"
}
#include "../Core/SwitecX12-lib/SwitecX12.hpp"
#include "utils.h"
#include "gfx.h"
#include "ugfx_widgets.h"
#include "../Quaternion/Quaternion.hpp"

/*
 * Milisecond timers, controlled by the main while loop, for various
 * slow functions
 */
#define SAMPLE_TIME_MS_LED    1000
#define SAMPLE_TIME_MS_PRINT   750
#define SAMPLE_TIME_MS_UPDATES   (1000/24)



/*
 * #defines used to control what happens in teh main loop
 */
//#define PRINT_TO_USB

//#define SWEEP_GAUGES  // sweep needles forever
//#define SIM_GAUGES       // generate simulated rpm and mph

// enable one of these to get acceleromter data
//#define ACC_USE_BLOCK   // use blocking calls
#define ACC_USE_IT    // use interrupt calls (not wokring)



extern I2C_HandleTypeDef hi2c1;
extern SPI_HandleTypeDef hspi1;
extern TIM_HandleTypeDef htim2;
extern TIM_HandleTypeDef htim16;

MCP4725 dac;
BMI088 imu;
uint8_t regAddr;

float rpm, speed;

extern "C" {



// flags used by accelerometer in IT mode
volatile bool acc_int_rdy = false;	// we got exti saying data ready
volatile bool do_convert = false;	// we received the raw data
volatile bool i2c_error = false;

bool rpm_alert = false;
bool rpm_alert_has_lock = false;
bool acc_has_lock = false;
volatile unsigned i2c_lock = 0;

/*
 * exti interrupts from IMU
 */
void HAL_GPIO_EXTI_Callback (uint16_t GPIO_Pin)
{
  if (GPIO_Pin == INT_ACC_Pin)
  {
    acc_int_rdy = true;
  }
  else if (GPIO_Pin == INT_GYR_Pin)
  {
    //BMI088_ReadGyroscopeDMA (&imu);
  }
}


/*
 * this callback fires when the acceleromter read finishs,
 * its currently the only thing using IT mem reads
 */
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
  do_convert = true;

  bool was_locked = acc_has_lock;
  acc_has_lock = false;
  if(was_locked)
    unlock_mutex(&i2c_lock);
}

void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{

}

/*
 * fires when DAC write finishes.  currently the only thing using
 * master transmits
 */
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
  bool was_locked = rpm_alert_has_lock;
  rpm_alert_has_lock = false;
  if(was_locked)
    unlock_mutex(&i2c_lock);
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
  i2c_error = true;
}

/*
 *
 * Speed and Tach exti
 *
 * at 100hz it takes 288 seconds to go 7 miles (4114 ticks / mile)
 * 4114 ticks = 1 mile, 4114 hz = 1 mile per second, 4114hz/3600s = 1.143hz = 1 mph
 *
 * the gauge face says 1025rev=1mile, so that would be 4100 ticks, that would be 1.38888hz/mph
 *
 * See https://www.3si.org/threads/speed-sensor-gear-ratio.831219/#post-1056408948
 *
 * 27 tooth variant (trans pre feb 1993?) 1.117hz/mph
 * 28 tooth 1.078 hz/mp
 *
 */
#define SPEEDOIND 0
#define TACHIND 1
#define IDLE   0
#define DONE   1
#define F_CLK  (SystemCoreClock)
#define OVERFLOW_MS ((int)(1000*65536.f/(float)F_CLK))
#define MPH_PER_HZ (1.38888) //(1.11746031667) //( 1.07755102 )
#define RPM_PER_HZ ( 20 ) // 3 ticks per revolution
volatile uint8_t state[2] = {IDLE, IDLE};
volatile uint32_t T1[2] = {0,0};
volatile uint32_t T2[2] = {0,0};
volatile uint32_t ticks[2] = {0,0};
volatile uint32_t TIM2_OVC[2] = {0,0};
volatile uint32_t speed_tick_count = 0;

/* i originally measured that every 3 ticks of the speedo, the odo was stepped once.
 * and with our stepper i think a full step is actually 12 micro steps.
 * so the numbers below should be 3 and 12.  but those aren't looking right.
 * so i tweaked it.  well, i will tweak it once i get some measurements again.
 */
#define SPEED_TICKS_PER_ODO_TICK (3)
#define ODO_STEPS_PER_TICK (12)
volatile bool odo_tick_flag = false;

void HAL_TIM_IC_CaptureCallback (TIM_HandleTypeDef *htim)
{
  if(htim->Instance != TIM2)
    return;

  int ch = (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3) ? SPEEDOIND : TACHIND;
  if (state[ch] == IDLE)
  {
    T1[ch] = (ch==SPEEDOIND) ? TIM2->CCR3 : TIM2->CCR4;
    TIM2_OVC[ch] = 0;
    state[ch] = DONE;
  }
  else if (state[ch] == DONE)
  {
    T2[ch] = (ch==SPEEDOIND) ? TIM2->CCR3 : TIM2->CCR4;
    ticks[ch] = (T2[ch] + (TIM2_OVC[ch] * 65536)) - T1[ch];
    state[ch] = IDLE;
    TIM2_OVC[ch] = 0;
  }

  /*
   * flag for an odo tick every 3 (or whatever) speedo ticks
   * as this is a unidirectional flag we dont need a mutex
   *
   * todo: this is a a single threaded devies, use an odo tick
   * count instead of a flag, and just incrment it here and decrement
   * it elsewhere
   */
  if(ch == SPEEDOIND && !odo_tick_flag)
  {
    speed_tick_count ++;
    if(speed_tick_count >= SPEED_TICKS_PER_ODO_TICK)
    {
      speed_tick_count = 0;
      odo_tick_flag = true;
    }
  }

}



/*
 * keep track of how many times the timer elapsed so we can use
 * that to calc the actual time between ticks.
 *
 * note, if this gets too high then assume no more ticks are coming
 * and we need to say the freq is 0
 */
void HAL_TIM_PeriodElapsedCallback (TIM_HandleTypeDef *htim)
{
  if(htim->Instance == TIM2)
  {
    TIM2_OVC[0]++;
    TIM2_OVC[1]++;
    if(TIM2_OVC[0]*OVERFLOW_MS > 250)
    {
      TIM2_OVC[0] = 0;
      ticks[0] = 0;
      state[0] = IDLE;
    }
    if(TIM2_OVC[1]*OVERFLOW_MS > 250)
    {
      TIM2_OVC[1] = 0;
      ticks[1] = 0;
      state[1] = IDLE;
    }
  }
  else if(rpm_alert && rpm_alert_has_lock && htim->Instance == TIM16)
  {
    // tim16?
//    static uint16_t valarr[16] =
//    { 0+2048, 383+2048, 707+2048, 924+2048, 1000+2048, 924+2048, 707+2048, 383+2048, 0+2048, -383+2048, -707+2048, -924+2048, -1000+2048, -924+2048,
//        -707+2048, -383+2048 };
//    static int16_t valarr[16] =
//    { -1000, 1000, -1000, 1000, -1000, 1000, -1000, 1000, -1000, 1000, -1000, 1000, -1000, 1000, -1000, 1000,  };
    static int16_t valarr[16] =
    { 0, 707, 1000, 707, 0, -707, -1000, -707,  0, 707, 1000, 707, 0, -707, -1000, -707, };
    static uint16_t valarr_ctr = 0;
    int16_t val = ( valarr[valarr_ctr & 0xf]  * 2 + 2048 ) & 0x0fff;
    valarr_ctr++;
#define lowByte(x)            ((uint8_t)(x%256))
#define highByte(x)             ((uint8_t)(x/256))
    static uint8_t arr[2];
    arr[1] = lowByte(val);
    arr[0] = highByte(val);
    HAL_I2C_Master_Transmit_IT(
      &hi2c1,
      dac._i2cAddress,
      arr,
      2);
  }
}

/*
 * override the _weak definition in the hal
 * this code is used for printf and puts to do trhough teh jtag interface
 */
int _write(int32_t file, uint8_t *ptr, int32_t len)
{
    int i = 0;
    for (i = 0; i < len; i++)
    {
        ITM_SendChar((*ptr++));
    }
    return len;
}

} // extern C


int get_x12_ticks_rpm( float rpm )
{
  const float MIN_RPM = 500;
  const float ZERO_ANGLE = 5;    // degrees beyond the stopper to get to 0
  const float MIN_RPM_ANGLE = 3; // degrees from zero to MIN_RPM
  const float DEGREES_PER_RPM_MIN = MIN_RPM_ANGLE / MIN_RPM;
  const float DEGREES_PER_RPM = ( 21.5 / 1000.  );

  if( rpm<MIN_RPM )
    return (rpm * DEGREES_PER_RPM_MIN + ZERO_ANGLE) * 12.;
  else
    return ((rpm * DEGREES_PER_RPM + ZERO_ANGLE) - MIN_RPM_ANGLE ) * 12.;
}

int get_x12_ticks_speed( float speed )
{
  const float MIN_MPH = 10;
  const float ZERO_ANGLE = 5;    // degrees beyond the stopper to get to 0
  const float MIN_MPH_ANGLE = 3; // degrees from zero to MIN_RPM
  const float DEGREES_PER_MPH_MIN = MIN_MPH_ANGLE / MIN_MPH;
  const float DEGREES_PER_MPH = ( 1.31 );

  if( speed<MIN_MPH )
    return (speed * DEGREES_PER_MPH_MIN + ZERO_ANGLE) * 12.;
  else
    return ((speed * DEGREES_PER_MPH + ZERO_ANGLE) - MIN_MPH_ANGLE ) * 12.;
}


/*
 * reads the two ports, sets one of them to have pull up resistors,
 * then reads again
 */
int io_exp_init()
{
  uint8_t status = 0;
  uint8_t buffer[2];
  status |= HAL_I2C_Mem_Read(
            &hi2c1,
            0b01000000,
            0, 1,
            buffer,
            2,
            1000);

  buffer[0] = 0xff; buffer[1] = 0xff;
  status |= HAL_I2C_Mem_Write(
            &hi2c1,
            0b01000000,
            0x46, 1,
            buffer,
            2,
            1000);

  buffer[0] = 0xff; buffer[1] = 0xaa;
  status |= HAL_I2C_Mem_Write(
            &hi2c1,
            0b01000000,
            0x48, 1,
            buffer,
            2,
            1000);

  buffer[0] = 0x00; buffer[1] = 0x00;
  status |= HAL_I2C_Mem_Read(
            &hi2c1,
            0b01000000,
            0, 1,
            buffer,
            2,
            1000);

  return (buffer[0]!=0xFF) | (buffer[1]!=0xAA) | status;
}


int movingAvg(int *ptrArrNumbers, long *ptrSum, int *pos, int len, int nextNum)
{
  //Subtract the oldest number from the prev sum, add the new number
  *ptrSum = *ptrSum - ptrArrNumbers[*pos] + nextNum;
  //Assign the nextNum to the position in the array
  ptrArrNumbers[*pos] = nextNum;

  (*pos)++;
  if((*pos)>=len)
    (*pos) = 0;

  //return the average
  return *ptrSum / len;
}

int main_cpp(void)
{



  // init our 64-bit system-tick counter based on teh DWT timer
  init_get_cycle_count ();

  /* Timers */
  uint32_t timerLoop = 0;
  uint32_t timerLED	= 0;
  uint32_t timerIGN = 0;
  uint32_t timerPrint = 0;
  uint32_t timerUpdates = 0;
  bool flagSlow = false;

  /* USB data buffer */
  const int bufLen = 256;
  char logBuf[bufLen];

  /*
   * Turn on mcu-controlled pwr-en signal.
   */
  HAL_GPIO_WritePin ( PWREN_GPIO_Port, PWREN_Pin, GPIO_PIN_SET );


  /*
   * init graphics library
   */
  gfxInit();
  font_t font = gdispOpenFont("DejaVuSans10");
  font_t fontMits20 = gdispOpenFont("BITSUMIS20");
  gImage myImage;
  uint8_t data[] = {
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x34, 0x08, 0x06, 0x00, 0x00, 0x00, 0x42, 0x65, 0x30, 0xa8, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xae, 0xce, 0x1c, 0xe9, 0x00, 0x00, 0x08, 0xc7, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0xed, 0x5b, 0x6f, 0x6c, 0x53, 0xd7, 0x15, 0x3f, 0xf7, 0xbe, 0xf7, 0xec, 0x04, 0x4d, 0xad, 0x1a, 0x2d, 0xfb, 0xc0, 0xc4, 0x34, 0x2d, 0xa9, 0x63, 0x87, 0x35, 0x6c, 0x98, 0x26, 0x84, 0x74, 0x29, 0xd1, 0xd2, 0xa9, 0x9f, 0xba, 0x74, 0xd2, 0xaa, 0xa9, 0xa3, 0x20, 0x84, 0xca, 0xdc, 0x8e, 0x0f, 0x5b, 0xbf, 0xa5, 0x9b, 0x98, 0x25, 0xb6, 0xa2, 0x69, 0x1f, 0x2a, 0xa4, 0x8d, 0x8d, 0xa9, 0x80, 0x14, 0xa1, 0xae, 0x6a, 0xd5, 0x36, 0x20, 0x51, 0x31, 0xad, 0x2c, 0x2c, 0x1b, 0x4d, 0x93, 0x26, 0x4d, 0x08, 0xab, 0xa1, 0x24, 0x68, 0x61, 0x42, 0x7c, 0x58, 0x24, 0xba, 0xaa, 0xed, 0x4c, 0xde, 0xbf, 0x33, 0x9d, 0x67, 0x3f, 0xe7, 0xd9, 0xbc, 0x7f, 0x90, 0x6b, 0xc9, 0xae, 0xdf, 0x93, 0x22, 0xd9, 0xcf, 0xf7, 0x9e, 0xbf, 0xbf, 0x7b, 0xce, 0xb9, 0xe7, 0xde, 0x30, 0x88, 0x9e, 0x86, 0xb6, 0x00, 0x6b, 0x68, 0xed, 0x23, 0xe5, 0x21, 0x02, 0x40, 0x83, 0x83, 0xa0, 0xaa, 0x00, 0xf8, 0x4b, 0xac, 0x03, 0x1f, 0x51, 0x3f, 0xac, 0x2a, 0x8f, 0x06, 0xf7, 0xdf, 0x9a, 0xd5, 0xaf, 0xaa, 0x73, 0x26, 0x59, 0x02, 0x9b, 0x9e, 0x7d, 0x32, 0xbd, 0xe9, 0x77, 0xd9, 0xf7, 0xd7, 0x2c, 0x69, 0x44, 0xa0, 0x2a, 0x16, 0xa8, 0x1a, 0x00, 0xa6, 0xa4, 0x0e, 0x64, 0x26, 0x07, 0x40, 0x0e, 0x0f, 0xc2, 0x07, 0x55, 0xe3, 0x53, 0x15, 0xab, 0x34, 0x10, 0xd1, 0xaa, 0x38, 0x26, 0xf7, 0xfc, 0x6f, 0xbe, 0x9e, 0x7f, 0xe1, 0xa5, 0x8b, 0x06, 0x30, 0x90, 0xc0, 0x80, 0x5b, 0xb1, 0xa6, 0x95, 0x3e, 0xf5, 0x62, 0x53, 0x03, 0xd9, 0xb5, 0x6e, 0x54, 0xad, 0x0a, 0x00, 0xde, 0xe7, 0x9d, 0xa8, 0x9b, 0xa6, 0x65, 0x04, 0xc6, 0x18, 0x20, 0x98, 0xd0, 0x8d, 0x51, 0x2d, 0x50, 0x8b, 0xa8, 0x10, 0x0e, 0x80, 0x37, 0xef, 0xfb, 0xc6, 0xb5, 0x2f, 0xff, 0x37, 0xff, 0x15, 0xc0, 0x55, 0xd2, 0x32, 0xe3, 0xf0, 0xb1, 0x6c, 0xc0, 0x80, 0x16, 0x81, 0xa0, 0xd6, 0x40, 0x20, 0x1c, 0x00, 0xb3, 0xac, 0x03, 0x0d, 0x5a, 0xf3, 0xc8, 0x4b, 0xba, 0x4a, 0xc0, 0x80, 0xe2, 0xff, 0x46, 0xb8, 0x24, 0x9c, 0x5f, 0xad, 0x19, 0xb4, 0xde, 0xe4, 0x11, 0xea, 0x90, 0x77, 0xd9, 0xd7, 0x90, 0x63, 0xcc, 0xd3, 0x06, 0x86, 0x02, 0xd0, 0xab, 0x5d, 0x16, 0xca, 0xb3, 0xde, 0x0c, 0x5e, 0x6b, 0xf2, 0x0a, 0x75, 0xc6, 0x0c, 0xa4, 0xac, 0xd5, 0xef, 0xf5, 0x98, 0x8c, 0x83, 0xfa, 0xbd, 0x47, 0x9e, 0xeb, 0x7f, 0xfd, 0xd0, 0x8b, 0xb5, 0x66, 0x88, 0x46, 0x95, 0x47, 0x18, 0x00, 0x26, 0xa5, 0x04, 0x32, 0x63, 0x35, 0xec, 0x7b, 0x19, 0x14, 0xb9, 0x06, 0x3d, 0xe6, 0x55, 0x61, 0x7c, 0x1b, 0xd5, 0x71, 0xa2, 0xf4, 0x16, 0xe2, 0x88, 0xf9, 0x67, 0x7f, 0xf9, 0xc3, 0x4f, 0x7f, 0xff, 0xea, 0x09, 0x19, 0xd5, 0x10, 0x72, 0xa9, 0x60, 0x28, 0xf7, 0x42, 0xaf, 0x36, 0x2b, 0x84, 0x77, 0x08, 0x86, 0xd1, 0x10, 0x1f, 0x0b, 0x08, 0x71, 0xc2, 0x24, 0x4f, 0xa2, 0x6c, 0x32, 0xf0, 0x0b, 0xff, 0xb6, 0x0c, 0xc4, 0x50, 0xe5, 0x26, 0xf4, 0x99, 0x57, 0x84, 0xf0, 0x8e, 0xbc, 0xbb, 0x36, 0x0b, 0x08, 0x71, 0xc2, 0xf9, 0xc4, 0xa3, 0xaf, 0xca, 0x57, 0x97, 0xbe, 0xcf, 0x8c, 0x60, 0x61, 0x4c, 0x06, 0x40, 0x99, 0xa2, 0xcf, 0x88, 0x8a, 0xc1, 0x60, 0x6b, 0x55, 0x7f, 0x84, 0x10, 0x00, 0x90, 0x98, 0xe3, 0x3c, 0x85, 0xeb, 0x4c, 0x6a, 0xf9, 0x78, 0x3f, 0xb4, 0x1d, 0x34, 0x40, 0x87, 0x6e, 0x58, 0x10, 0xc6, 0xb7, 0xfa, 0x26, 0xfa, 0x7c, 0x73, 0x10, 0xe6, 0x08, 0x44, 0x64, 0x53, 0x2c, 0x61, 0x52, 0xf3, 0xd7, 0x73, 0x17, 0xc0, 0x4d, 0x58, 0x49, 0xb6, 0x9f, 0x7c, 0x38, 0xf7, 0xd6, 0xd0, 0xe7, 0xdb, 0xac, 0xf5, 0xa3, 0x9d, 0x30, 0x00, 0x90, 0xca, 0x93, 0xb1, 0x4e, 0x64, 0xaa, 0x4f, 0x0c, 0x90, 0x11, 0xba, 0xf5, 0xa8, 0x1b, 0x58, 0x4b, 0xf0, 0x10, 0x0a, 0x00, 0x52, 0x6c, 0x82, 0x27, 0x51, 0x31, 0x19, 0x98, 0x15, 0xfd, 0x00, 0x93, 0x9b, 0xb0, 0x35, 0x2a, 0xfc, 0x6a, 0xc9, 0xf7, 0x96, 0x2c, 0xc2, 0x01, 0xf0, 0xb7, 0x2f, 0x74, 0x61, 0xec, 0x33, 0x15, 0x62, 0x58, 0xd8, 0x15, 0x14, 0xf2, 0x3e, 0x42, 0x53, 0x8c, 0x41, 0x97, 0x1a, 0xb5, 0x82, 0x6b, 0x0d, 0x01, 0xc2, 0x01, 0x40, 0x0a, 0xce, 0xf0, 0x14, 0xa2, 0x15, 0x05, 0x0a, 0xe9, 0x00, 0x39, 0x83, 0x1e, 0x33, 0x72, 0x7e, 0xad, 0x39, 0xbf, 0x2a, 0x11, 0x80, 0x88, 0xbe, 0xfd, 0xcd, 0x47, 0x5f, 0xf8, 0xe2, 0xec, 0xb5, 0x61, 0x95, 0x0e, 0x85, 0x18, 0x00, 0x93, 0x25, 0xe8, 0xd1, 0xa2, 0x4b, 0x21, 0x0d, 0x03, 0x00, 0x52, 0xf4, 0x02, 0x24, 0x51, 0x03, 0x00, 0x53, 0x42, 0xe8, 0x36, 0xa2, 0xc2, 0xaf, 0x16, 0x9d, 0x5f, 0xb5, 0x08, 0x60, 0x85, 0x7d, 0x44, 0x36, 0xcd, 0x3b, 0x4d, 0xe3, 0xf1, 0x6f, 0x1f, 0xdc, 0xfa, 0xc6, 0x6f, 0x9f, 0xaf, 0x55, 0x03, 0x34, 0xba, 0x5c, 0x55, 0xa9, 0x01, 0x6c, 0xa3, 0xce, 0xcb, 0x29, 0xec, 0xd2, 0xa3, 0xdc, 0x5f, 0xcb, 0x20, 0x0b, 0x0d, 0x80, 0xb1, 0xa6, 0x14, 0xc6, 0x75, 0x00, 0x2a, 0xee, 0xfc, 0x1f, 0x6e, 0xe5, 0x7d, 0x00, 0x1d, 0xbe, 0x65, 0x5c, 0x66, 0xe7, 0xa5, 0x44, 0xe1, 0x7c, 0x18, 0xe5, 0x40, 0x3b, 0x30, 0xd0, 0xc1, 0xe4, 0x12, 0x3c, 0x54, 0x83, 0xa0, 0x69, 0x6d, 0x6d, 0xcd, 0xc5, 0xe3, 0xf1, 0x4f, 0xae, 0x5f, 0xbf, 0xde, 0x13, 0xa8, 0x88, 0xe0, 0x01, 0x3b, 0x77, 0xee, 0xec, 0x3a, 0x7d, 0xfa, 0xf4, 0x2b, 0x1b, 0x36, 0x6c, 0x78, 0x63, 0x6e, 0x6e, 0xee, 0xe7, 0x22, 0xc9, 0x07, 0x79, 0xd3, 0xe2, 0x75, 0xfe, 0xa9, 0x1f, 0x3f, 0x05, 0x2f, 0xff, 0x75, 0x24, 0x66, 0x00, 0x04, 0x1f, 0xf8, 0x72, 0xd0, 0x99, 0x01, 0x26, 0xac, 0x40, 0x2f, 0xfe, 0x8b, 0x4d, 0xdd, 0xb7, 0x4d, 0x65, 0x1f, 0x7d, 0xac, 0x70, 0xdf, 0x26, 0xf1, 0xaa, 0x4a, 0x3a, 0x43, 0xd0, 0xb9, 0x0c, 0x7d, 0xc6, 0x3f, 0x43, 0xc9, 0x46, 0xd0, 0x72, 0x18, 0xa4, 0x6c, 0x8e, 0x24, 0x49, 0x68, 0x18, 0x85, 0x03, 0x0a, 0xeb, 0x6e, 0x22, 0x5a, 0xf7, 0xd4, 0xec, 0xf1, 0xce, 0xcf, 0x6e, 0x36, 0xa5, 0xdf, 0xe9, 0xef, 0xb6, 0xce, 0x96, 0x2c, 0xcb, 0xa0, 0xeb, 0xba, 0xcd, 0xcb, 0x49, 0xaf, 0x92, 0x0e, 0xba, 0xf0, 0xbd, 0x8d, 0xd7, 0xd0, 0xd0, 0xd0, 0x4f, 0x46, 0x47, 0x47, 0x0f, 0x29, 0x8a, 0xb2, 0xa8, 0x69, 0x5a, 0x5b, 0x71, 0x00, 0xdb, 0xbd, 0x7b, 0xf7, 0x86, 0xe3, 0xc7, 0x8f, 0xff, 0xbb, 0x72, 0x82, 0x83, 0xa6, 0xb5, 0xb4, 0xec, 0xf1, 0x2e, 0x4a, 0xb8, 0xe9, 0x5a, 0x66, 0xa3, 0x50, 0x46, 0x1e, 0xe7, 0x1d, 0xd8, 0x64, 0x52, 0x8b, 0xd7, 0xaf, 0xd3, 0x5f, 0x60, 0x4f, 0x00, 0x59, 0x91, 0x4c, 0xe8, 0x33, 0x56, 0x4f, 0xfb, 0xe6, 0x20, 0x19, 0xea, 0xa0, 0xb8, 0x34, 0x5f, 0x36, 0xa1, 0x4f, 0x0f, 0x7d, 0x5a, 0xe8, 0x09, 0x00, 0xc6, 0x18, 0x22, 0x16, 0x7e, 0x76, 0x03, 0x00, 0xfd, 0x6e, 0x59, 0xb0, 0x38, 0x86, 0x73, 0x5e, 0xfa, 0x4c, 0x60, 0xb1, 0xe7, 0xf7, 0xf7, 0xf7, 0xff, 0x61, 0x7c, 0x7c, 0xfc, 0x19, 0x1a, 0x6b, 0x83, 0x8a, 0xc6, 0x9a, 0xa6, 0x15, 0xeb, 0x42, 0x03, 0x80, 0x64, 0x48, 0x26, 0x93, 0x96, 0x2c, 0xf4, 0x77, 0xe9, 0xd2, 0x25, 0xa2, 0x61, 0xfb, 0x8d, 0x55, 0x02, 0xc0, 0xa6, 0xbd, 0x67, 0xcf, 0x9e, 0xaf, 0x1e, 0x3d, 0x7a, 0xf4, 0x9a, 0x65, 0x1f, 0xce, 0x91, 0xe6, 0x34, 0x37, 0x37, 0x5f, 0xc9, 0xe7, 0xf3, 0x1d, 0x41, 0xfc, 0x1d, 0xe0, 0x70, 0x95, 0x33, 0x10, 0x00, 0x53, 0x4d, 0x1b, 0x57, 0xd8, 0x2d, 0x3d, 0x86, 0x61, 0x7b, 0x46, 0xd6, 0x69, 0x9f, 0x04, 0xbd, 0xc6, 0xea, 0xb6, 0xef, 0x9d, 0xa1, 0x67, 0xf6, 0x4a, 0xa3, 0x6f, 0x1f, 0xf1, 0x3b, 0x27, 0x70, 0xa2, 0x97, 0xd6, 0xa9, 0x0c, 0x08, 0xe9, 0x70, 0x37, 0x89, 0xed, 0x55, 0x46, 0x46, 0xfd, 0x04, 0x11, 0xef, 0x71, 0xd0, 0x72, 0xfe, 0xe6, 0x16, 0x01, 0xec, 0xa1, 0x96, 0x71, 0x2a, 0x56, 0x96, 0x85, 0x0d, 0x87, 0xa3, 0x4b, 0x64, 0x09, 0x18, 0x34, 0xf6, 0x4e, 0x01, 0xe0, 0x04, 0x9b, 0x4d, 0x4c, 0x92, 0x24, 0x1b, 0x04, 0x65, 0x00, 0x18, 0x18, 0x18, 0xf8, 0xd9, 0xd8, 0xd8, 0xd8, 0xaf, 0x5c, 0x64, 0xb2, 0x40, 0x40, 0xef, 0x0d, 0xc3, 0x08, 0x04, 0xe0, 0x9a, 0x01, 0x30, 0x2d, 0x25, 0xd1, 0x0c, 0x71, 0xcc, 0xbb, 0x6a, 0x49, 0x06, 0x3d, 0x2e, 0x97, 0x3f, 0xdf, 0xe3, 0xf7, 0x23, 0x5a, 0x51, 0x24, 0xdc, 0x43, 0x1d, 0xc4, 0x74, 0xb8, 0x4b, 0xa4, 0x6e, 0x4e, 0x86, 0x4d, 0x9b, 0x36, 0xed, 0x9e, 0x9f, 0x9f, 0x3f, 0x66, 0x87, 0x7d, 0x8f, 0x14, 0x10, 0x08, 0x00, 0x9f, 0xf0, 0x5a, 0x36, 0xd7, 0xa3, 0xab, 0x7a, 0x5b, 0x0a, 0xb0, 0xa3, 0x0d, 0x4d, 0xa6, 0x95, 0x4c, 0xe9, 0xa4, 0xf8, 0xae, 0x0c, 0x00, 0xe9, 0x74, 0xba, 0x6b, 0x66, 0x66, 0x66, 0x7e, 0xad, 0xfc, 0xd7, 0x04, 0x80, 0x39, 0xb6, 0x11, 0x0d, 0xa4, 0x7e, 0x1e, 0xfa, 0xdc, 0xf4, 0x2b, 0xb0, 0x28, 0x1a, 0x18, 0xcc, 0xee, 0x8d, 0xaf, 0x6d, 0x9d, 0x7a, 0xfd, 0x09, 0x37, 0x37, 0x4f, 0x41, 0x27, 0x72, 0x5e, 0x50, 0x3c, 0xcc, 0xd3, 0x0c, 0x08, 0x0f, 0x40, 0x60, 0x0f, 0xc1, 0xb9, 0x7a, 0x2d, 0x51, 0x8a, 0xb4, 0xcb, 0xf2, 0xdf, 0xdd, 0x00, 0xc0, 0x59, 0x43, 0x38, 0x74, 0x54, 0xac, 0x0a, 0x77, 0xf5, 0x09, 0x9d, 0x02, 0x2a, 0x75, 0x26, 0x99, 0x14, 0x45, 0x81, 0xf6, 0xf6, 0xf6, 0xd1, 0x5c, 0x2e, 0xf7, 0x78, 0x65, 0x0a, 0x90, 0x65, 0x19, 0x75, 0x5d, 0xb7, 0x6c, 0x6b, 0x47, 0x8f, 0x6c, 0x36, 0x2b, 0x65, 0xb3, 0x59, 0xa7, 0x01, 0x2b, 0xf5, 0x77, 0x33, 0xad, 0x67, 0xa4, 0xf0, 0x4d, 0x01, 0x13, 0x72, 0x02, 0x25, 0x3d, 0xb8, 0xec, 0xb3, 0x39, 0xea, 0x31, 0x06, 0xdb, 0x7c, 0xfa, 0xfd, 0xb3, 0x4a, 0x0a, 0x35, 0xcd, 0xfb, 0xd2, 0xa8, 0x53, 0x72, 0x8a, 0x00, 0x1a, 0x43, 0xf8, 0x74, 0xfb, 0xe6, 0x3f, 0x0e, 0x8e, 0xbd, 0xfc, 0x23, 0x1f, 0xc0, 0x58, 0x04, 0xb7, 0x6f, 0xdf, 0xae, 0x9c, 0x3b, 0x77, 0x4e, 0xeb, 0xec, 0xec, 0xec, 0xcf, 0xe5, 0x72, 0x7f, 0xaf, 0x2c, 0xf6, 0xee, 0x06, 0x00, 0x44, 0xb7, 0x12, 0x04, 0xb6, 0x1c, 0x3b, 0x76, 0xec, 0x78, 0xfa, 0xc4, 0x89, 0x13, 0x2f, 0x05, 0xe5, 0xe0, 0xa0, 0x22, 0x90, 0x52, 0x4c, 0x26, 0x93, 0x79, 0xf2, 0xf0, 0xe1, 0xc3, 0x7f, 0x72, 0xa9, 0x01, 0x5c, 0xf9, 0x7b, 0x14, 0x81, 0x7e, 0x6b, 0xea, 0xce, 0x01, 0x30, 0x29, 0xdd, 0x8f, 0xcc, 0x08, 0x1f, 0xb2, 0x81, 0x23, 0x3c, 0xf8, 0xca, 0x65, 0x99, 0x3d, 0xe1, 0x7f, 0x2f, 0xe8, 0x1d, 0xde, 0x89, 0x8a, 0x59, 0x79, 0x56, 0xe8, 0x25, 0x3b, 0x07, 0x99, 0x01, 0x6c, 0xc6, 0x9c, 0x1f, 0x50, 0x4b, 0x2b, 0x90, 0x72, 0x33, 0xe5, 0xd4, 0x62, 0x85, 0x8e, 0xed, 0xed, 0xed, 0xaf, 0x2d, 0x2e, 0x2e, 0x52, 0x34, 0x72, 0xab, 0xc6, 0x9d, 0x34, 0xbd, 0x6a, 0x80, 0x32, 0xc1, 0x06, 0x07, 0x07, 0xbf, 0x7b, 0xf6, 0xec, 0xd9, 0x51, 0x47, 0x18, 0x0f, 0xcc, 0xc1, 0x95, 0x00, 0xa0, 0xe8, 0x67, 0x47, 0x4b, 0x22, 0x4e, 0x11, 0xa0, 0xb8, 0x53, 0x71, 0x2b, 0x02, 0xcb, 0xf8, 0xb7, 0xb5, 0xb5, 0xbd, 0xb9, 0xb4, 0xb4, 0x34, 0x44, 0xe3, 0x03, 0x00, 0xed, 0x96, 0x9e, 0xc2, 0x17, 0x81, 0x13, 0xdb, 0x7e, 0x90, 0x55, 0x26, 0x2e, 0xfc, 0xc2, 0x2c, 0x56, 0xc7, 0x7e, 0xd0, 0xa2, 0x95, 0x9a, 0xe7, 0x3a, 0xc8, 0x12, 0x87, 0xad, 0x21, 0xfe, 0xf3, 0xe7, 0xe4, 0xba, 0xb6, 0x5b, 0x2d, 0xaa, 0x14, 0x8f, 0x87, 0x8c, 0x2c, 0x12, 0x20, 0xa8, 0xeb, 0x62, 0xd0, 0xfb, 0xbf, 0x8b, 0x5e, 0x20, 0x28, 0x29, 0x46, 0xab, 0xd5, 0xce, 0xab, 0x9a, 0x46, 0x8d, 0xe8, 0xd5, 0x74, 0x70, 0xb7, 0x11, 0xc0, 0x35, 0x9e, 0x16, 0x77, 0x17, 0x07, 0x0e, 0x1c, 0x48, 0xec, 0xdf, 0xbf, 0xff, 0x8a, 0x9d, 0xc3, 0x5d, 0xc6, 0xde, 0xb6, 0x0d, 0x73, 0xd6, 0x00, 0x34, 0x3e, 0x93, 0xc9, 0xc0, 0x91, 0x23, 0x47, 0x2c, 0x87, 0xca, 0xb2, 0x7c, 0xd5, 0xb9, 0x0d, 0xf4, 0x5c, 0x16, 0xc5, 0x9d, 0x40, 0x51, 0x3f, 0xf1, 0xdb, 0xc0, 0x69, 0x9e, 0x42, 0xd3, 0xaa, 0xfc, 0x82, 0xc3, 0x3f, 0xed, 0xef, 0xe9, 0xbe, 0x7f, 0x37, 0x86, 0xbf, 0xe3, 0x77, 0x81, 0x25, 0x71, 0xc5, 0x02, 0x57, 0xe0, 0x26, 0xa4, 0x78, 0x9c, 0x6c, 0x40, 0x37, 0x78, 0x6e, 0x0b, 0x4b, 0x06, 0x68, 0x6e, 0x6e, 0xfe, 0x4f, 0x3e, 0x9f, 0x6f, 0x75, 0xe4, 0xeb, 0x52, 0x3d, 0x70, 0xa7, 0x00, 0xd8, 0xb5, 0x6b, 0x57, 0xdb, 0xc8, 0xc8, 0xc8, 0xa2, 0x9b, 0x73, 0xed, 0xdc, 0x5c, 0x28, 0x7d, 0x4a, 0x5b, 0x4d, 0x37, 0x65, 0x30, 0x16, 0x8b, 0x81, 0xaa, 0xaa, 0xa5, 0x48, 0xe1, 0x04, 0x00, 0x7d, 0x8e, 0xc7, 0xe3, 0x40, 0x60, 0x25, 0xf9, 0x38, 0xe7, 0x8b, 0x86, 0x61, 0xb4, 0x93, 0xfc, 0xf4, 0x5e, 0x55, 0x55, 0xaa, 0x0f, 0xce, 0x2e, 0x2c, 0x2c, 0x0c, 0x56, 0x80, 0x21, 0x70, 0x7f, 0xef, 0x56, 0x07, 0x15, 0xdf, 0xf9, 0xf7, 0x01, 0xfe, 0x21, 0x27, 0xd4, 0x98, 0xce, 0xa9, 0xd0, 0x09, 0x7c, 0xac, 0xd2, 0x90, 0x31, 0xb8, 0x25, 0xa3, 0xfa, 0xb0, 0xf6, 0x61, 0x3c, 0x70, 0x42, 0x71, 0xc0, 0x07, 0xbf, 0x3e, 0xfc, 0xd8, 0x67, 0xc3, 0x87, 0x4e, 0x16, 0x5b, 0x86, 0xbe, 0xd3, 0xec, 0xf2, 0xf3, 0x1e, 0x26, 0x41, 0xca, 0x3d, 0x15, 0x54, 0xae, 0x00, 0xeb, 0x3b, 0xa5, 0x82, 0xe2, 0x36, 0x89, 0xbe, 0xde, 0x6d, 0x0a, 0xb0, 0xe6, 0x11, 0xad, 0xbd, 0x7b, 0xf7, 0x3e, 0x76, 0xe6, 0xcc, 0x99, 0xcd, 0x4b, 0x4b, 0x4b, 0x59, 0x47, 0x18, 0x67, 0x07, 0x0f, 0x1e, 0x6c, 0x1f, 0x1e, 0x1e, 0x5e, 0x20, 0x26, 0xad, 0xad, 0xad, 0xe7, 0x96, 0x97, 0x97, 0x07, 0x5a, 0x5a, 0x5a, 0xfe, 0x7c, 0xf3, 0xe6, 0xcd, 0xef, 0xd0, 0xbb, 0xf5, 0xeb, 0xd7, 0xcf, 0xde, 0xb8, 0x71, 0x63, 0xb3, 0x2d, 0x83, 0x25, 0x0c, 0xa2, 0x45, 0x93, 0xe8, 0xd8, 0x80, 0x38, 0x76, 0xec, 0xd8, 0x97, 0x32, 0x99, 0xcc, 0x84, 0xaa, 0xaa, 0xa5, 0x46, 0x90, 0xbd, 0xe7, 0xa7, 0x9d, 0xc2, 0xa9, 0x53, 0xa7, 0xee, 0xdd, 0xb7, 0x6f, 0xdf, 0x4f, 0x6d, 0xfe, 0x61, 0xfb, 0x10, 0x0e, 0xa7, 0x87, 0x4b, 0x01, 0x73, 0x2c, 0x81, 0x7a, 0x71, 0x65, 0x3a, 0xfe, 0xbf, 0xd3, 0xd5, 0x49, 0x1c, 0x01, 0xf2, 0x12, 0xc2, 0x43, 0xe1, 0x9b, 0x36, 0x25, 0x3a, 0x33, 0x3c, 0x51, 0xd8, 0xa1, 0xb1, 0xf2, 0x56, 0x9e, 0x3b, 0x1a, 0xe8, 0xb2, 0xa9, 0x0c, 0xd2, 0xd4, 0x48, 0x6c, 0xcb, 0x96, 0x2d, 0x56, 0x6c, 0xb7, 0x1f, 0x47, 0x33, 0xc7, 0x42, 0xb6, 0xc7, 0x8a, 0xf4, 0x05, 0x80, 0x3d, 0xc7, 0x6b, 0xcf, 0xed, 0xdc, 0xb5, 0x38, 0x2a, 0xf2, 0xd2, 0x4a, 0xa2, 0x36, 0xf1, 0xf2, 0xf2, 0x72, 0xaa, 0x52, 0x76, 0x45, 0x51, 0x3e, 0xd2, 0x34, 0xad, 0xa5, 0x62, 0x35, 0x96, 0x0d, 0x23, 0x7a, 0xe9, 0x74, 0xfa, 0xb9, 0xe9, 0xe9, 0xe9, 0x17, 0xed, 0x22, 0xd0, 0xd9, 0x7b, 0xa0, 0x68, 0x43, 0xfc, 0x6d, 0xd0, 0x15, 0xfb, 0x0f, 0x96, 0xaa, 0x3e, 0xfa, 0xda, 0x3c, 0x02, 0x23, 0x45, 0x70, 0x0c, 0x0e, 0xbb, 0xac, 0xa3, 0x71, 0x75, 0x69, 0x81, 0x08, 0x00, 0x75, 0xe9, 0x36, 0x71, 0x42, 0x47, 0x00, 0x10, 0x67, 0xcb, 0xba, 0xa4, 0x14, 0x01, 0xa0, 0x2e, 0xdd, 0x26, 0x4e, 0xe8, 0x08, 0x00, 0xe2, 0x6c, 0x59, 0x97, 0x94, 0x22, 0x00, 0xd4, 0xa5, 0xdb, 0xc4, 0x09, 0x1d, 0x01, 0x40, 0x9c, 0x2d, 0xeb, 0x92, 0x52, 0x04, 0x80, 0xba, 0x74, 0x9b, 0x38, 0xa1, 0x23, 0x00, 0x88, 0xb3, 0x65, 0x5d, 0x52, 0x8a, 0x00, 0x50, 0x97, 0x6e, 0x13, 0x27, 0x74, 0x04, 0x00, 0x71, 0xb6, 0xac, 0x4b, 0x4a, 0x11, 0x00, 0xea, 0xd2, 0x6d, 0xe2, 0x84, 0x8e, 0x00, 0x20, 0xce, 0x96, 0x75, 0x49, 0x29, 0x02, 0x40, 0x5d, 0xba, 0x4d, 0x9c, 0xd0, 0xff, 0x07, 0x96, 0x90, 0x05, 0x71, 0x17, 0x2c, 0xd2, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
  };
  gdispImageOpenMemory(&myImage,data);
  gdispImageDraw(&myImage, 0, 17, 128, 52, 0, 0);
  gdispFillString(50, 40, "3000GT", fontMits20, GFX_AMBER, GFX_BLACK);
  gdispFlush();


  /*
   * dac setup
   */
  MCP4725_init (&dac, &hi2c1, MCP4725A0_ADDR_A00, 3.30);
  if (!MCP4725_isConnected (&dac))
    exit(-1);
  if( MCP4725_setVoltage(&dac, 0, MCP4725_REGISTER_MODE, MCP4725_POWER_DOWN_100KOHM) )
    exit(-1);


  /*
   * dac output timer
   */
  HAL_TIM_Base_Start_IT(&htim16);

#if 0
#define lowByte(x)            ((uint8_t)(x%256))
#define highByte(x)             ((uint8_t)(x/256))

  int n = 0;
  uint16_t val;
  int16_t valarr[] =
  { 0, 383, 707, 924, 1000, 924, 707, 383, 0, -383, -707, -924, -1000, -924,
      -707, -383 };
  int valarrsz = sizeof(valarr) / sizeof(valarr[0]);
  uint8_t mode = 0;
  uint8_t powerType = 0;
  uint8_t buffer[4];
  my_transfer (dac.hi2c, dac._i2cAddress,  NULL, 0, 1000);
  while (1)
  {
    val = 2048 + (valarr[n] >> 2);
    n += 2;
    if (n >= valarrsz)
      n = 0;

    //MCP4725_setValue(&dac, val, MCP4725_FAST_MODE, MCP4725_POWER_DOWN_OFF);

    buffer[0] = mode | (powerType << 4) | highByte(val);
    buffer[1] = lowByte(val);

    my_transfer (dac.hi2c, dac._i2cAddress, buffer, 2, 1000);

    DWT_Delay(50);

  }
  my_transfer (dac.hi2c, dac._i2cAddress, buffer, -2, 1000);
#endif


  /*
   * io expander
   */
  if(io_exp_init())
    exit(-1);

  /*
   * Acc / Gyro setup
   */
  if(BMI088_Init(&imu, &hi2c1))
    exit(-1);


  /*
   * tach and speedo freq measurement setup
   */
  HAL_TIM_Base_Start_IT(&htim2);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_3); // speed
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_4); // tach

  /*
   * needle drivers
   *
   * reset the driver chip, then configure each motor driver
   */
  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_RESET );
  HAL_Delay(10);
  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_SET );

  //const int X27_STEPS = 315*12; // 315 degrees, 12 microsteps each?
  const int X27_STEPS = 240*12;

  SwitecX12 tachX12(
      X27_STEPS,
      STEP_TACH_GPIO_Port,
      STEP_TACH_Pin,
      DIR_TACH_GPIO_Port,
      DIR_TACH_Pin
      );

  SwitecX12 speedX12(
      X27_STEPS,
      STEP_SPEED_GPIO_Port,
      STEP_SPEED_Pin,
      DIR_SPEED_GPIO_Port,
      DIR_SPEED_Pin
      );

  SwitecX12 odoX12(
      0xFFFFFFFE,  // hopefully infinite
      STEP_ODO_GPIO_Port,
      STEP_ODO_Pin,
      DIR_ODO_GPIO_Port,
      DIR_ODO_Pin
      );

  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_RESET );
  HAL_Delay(10);
  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_SET );

  // zero out the tach and speedo
  for(int i=0; i<X27_STEPS; i++)
  {
    tachX12.step(-1);
    speedX12.step(-1);
    DWT_Delay(500);
  }
  tachX12.currentStep = 0; tachX12.stopped = true; tachX12.vel = 0;
  speedX12.currentStep = 0; speedX12.stopped = true; speedX12.vel = 0;
  HAL_Delay(200);

  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_RESET );
  HAL_Delay(10);
  HAL_GPIO_WritePin ( RESET_MOTOR_GPIO_Port, RESET_MOTOR_Pin, GPIO_PIN_SET );

  tachX12.setPosition (X27_STEPS);
  speedX12.setPosition (X27_STEPS);
  while (!tachX12.stopped && !speedX12.stopped)
  {
    tachX12.update ();
    speedX12.update ();
  }
  HAL_Delay(200);

  tachX12.setPosition (0);
  speedX12.setPosition (0);
  while  (!tachX12.stopped && !speedX12.stopped)
  {
    tachX12.update ();
    speedX12.update ();
  }
  HAL_Delay(200);


  /*
   * assume that the board is mounted with a known pitch angle, but that there is no yaw or roll
   */
  constexpr float pitch = 0. * M_PI / 180.0;
  constexpr float cosPitch = cos(pitch), sinPitch = sin(pitch);


  /*
   * Main while loop.
   *
   * We stay here until the ignition turns off.
   */
  bool firstAcc = false;
  while (1)
  {

    /* Toggle LED */
    if ((HAL_GetTick () - timerLED) >= SAMPLE_TIME_MS_LED)
    {
      // needs to be called occasionally to avoid looping
      get_cycle_count();

      HAL_GPIO_TogglePin ( LED_GPIO_Port, LED_Pin );
      timerLED = HAL_GetTick ();
    }

    /**
     * bmi088 triggered us that data is available, start reading it
     */
#ifdef ACC_USE_BLOCK
    if( acc_int_rdy )
    {
      // ~245us
      BMI088_ReadAccelerometer(&imu);
    }
#elif defined ACC_USE_IT
    if( do_convert )
    {
      BMI088_ConvertAccData(&imu); // converts raw buffered data to accel floats
      do_convert = false;
      rotateVectorKnownPitch(imu.acc_mps2, cosPitch, sinPitch);
      if(!firstAcc)
      {
        firstAcc = true;
      }
    }

    if( acc_int_rdy  )
    {
      if (!acc_has_lock)
        acc_has_lock = lock_mutex (&i2c_lock);
      if (acc_has_lock)
      {
        regAddr = BMI_ACC_DATA;
        uint8_t status = 1;
        while(status)
        {
          status = HAL_I2C_Mem_Read_IT(
            &hi2c1,
            ACC_ADDR,
            BMI_ACC_DATA, 1,
            imu.accRxBuf, 6);
        }
        acc_int_rdy = false;
      }
    }
#endif



    /* Print */
    if ((HAL_GetTick () - timerPrint) >= SAMPLE_TIME_MS_PRINT)
    {
      int ind = 0;
      ind += snprintf (logBuf+ind, bufLen-ind, "\033[1J");
      ind += snprintf (logBuf+ind, bufLen-ind, "tach: %.1f , speedo %.1f  \n",  rpm,  speed);
      ind += snprintf (logBuf+ind, bufLen-ind, "acc: %.1f, %.1f, %.1f", imu.acc_mps2[0],imu.acc_mps2[1],imu.acc_mps2[2]);
      if(flagSlow)
      {
	ind += snprintf (logBuf+ind, bufLen-ind, "main loop running slow \n");
      }
#ifdef PRINT_TO_USB
      CDC_Transmit_FS ((uint8_t*) logBuf, ind);
#else
      printf("%s", logBuf);
#endif
      timerPrint = HAL_GetTick ();
    }

    /*
     * Any updates we want presented to the user.
     *  Currently this is 20fps
     *
     */
#ifndef SWEEP_GAUGES
    if ((HAL_GetTick () - timerUpdates) >= SAMPLE_TIME_MS_UPDATES)
    {
#ifdef SIM_GAUGES
      rpm += (float)SAMPLE_TIME_MS_UPDATES / 1000. * 3000;
      if(rpm>7000)
        rpm = 0;
      speed += (float)SAMPLE_TIME_MS_UPDATES / 1000. * 40;
      if(speed>100)
        speed = 0;
      //speed = (imu.acc_mps2[2] / 9.8) * 50 + 50;
      if(speed > 100)
        speed = 100;
      if(speed < 10)
        speed = 10;
#else
      /*
       * convert ticks, to Hz, to RPM and Speed
       */
      rpm   = (ticks[TACHIND]==0) ? 0 : (float)F_CLK / (float)ticks[TACHIND];   // Actually this is Hz
      speed = (ticks[SPEEDOIND]==0) ? 0 : (float)F_CLK / (float)ticks[SPEEDOIND]; // Actually, this is Hz
      rpm = rpm * RPM_PER_HZ;
      if(rpm < 0) rpm = 0;
      else if(rpm > 9000) rpm = 9000;
      speed = speed * MPH_PER_HZ;
      if(speed < 0) speed = 0;
      else if(speed > 180) speed = 180;
#endif
      tachX12.setPosition( get_x12_ticks_rpm(rpm) );
      speedX12.setPosition( get_x12_ticks_speed(speed) );
      timerUpdates = HAL_GetTick ();


      /*
       * OLED display updates
       */
      gdispClear(GFX_BLACK);  // if the device doesnt support flushing, then this is immediate

      snprintf(logBuf, bufLen, "acc:%.1f,%.1f,%.1f", imu.acc_mps2[0],imu.acc_mps2[1],imu.acc_mps2[2]);
      gdispFillString(1, 16, logBuf, font, GFX_AMBER, GFX_BLACK);
      drawVertBarGraph(90, 17, 7, 45, 9.7, 0, imu.acc_mps2[0]);
      //drawHorzBarGraph(5, 50, 45, 7, 10, 0, imu.acc_mps2[2]);

      snprintf(logBuf, bufLen, "rpm: %.1f", rpm);
      gdispFillString(1, 25, logBuf, font, GFX_AMBER, GFX_BLACK);
      drawVertBarGraph(99, 17, 7, 45, 30, 0, rpm);

      snprintf(logBuf, bufLen, "spd: %.1f", speed);
      gdispFillString(1, 35, logBuf, font, GFX_AMBER, GFX_BLACK);
      drawVertBarGraph(109, 17, 7, 45, 30, 0, speed);

      // make x be -x, flip x and y
      drawGimball( 65, 45, 20, -imu.acc_mps2[1]/9.8*20, imu.acc_mps2[0]/9.8*20);

      // this box is exactly the size of the top yellow area on the
      // common amazon ssd1306, 0.96" displays
      gdispDrawBox(0,0,128,16,GFX_AMBER);

      // some devices dont support this and instead they draw whenever you call a drawing function
      // but its always safe to call it
      gdispFlush();


    }

    /*
     * odometer ticks
     */
    if(odo_tick_flag && odoX12.stopped)
    {
      odoX12.setPosition(odoX12.targetStep+ODO_STEPS_PER_TICK);
      odo_tick_flag = false;
    }
#else
    /*
     * temporarily sweep needle back and forth
     */
    static bool set = false;
    if ( set && tachX12.stopped && speedX12.stopped )
    {
      set = !set;
      tachX12.setPosition (get_x12_ticks_rpm(7000));
      speedX12.setPosition (get_x12_ticks_speed(180) );
    }
    else if ( !set && tachX12.stopped && speedX12.stopped )
    {
      set = !set;
      tachX12.setPosition (0);
      speedX12.setPosition (0);
    }
#endif

    /*
     * called as fast as possible, moves the motors if they need to be moved
     */
    speedX12.update();
    tachX12.update();
    odoX12.update();


    /*
     * shift alert
     */
    if( rpm > 6500  && (!rpm_alert || !rpm_alert_has_lock))
    {
      rpm_alert = true;
      if(!rpm_alert_has_lock)
        rpm_alert_has_lock = lock_mutex(&i2c_lock);
    }

    if( rpm < 6400 && rpm_alert )
    {
      rpm_alert = false;
    }


    /*
     * check ignition signal status.  we want it low for at least 10ms
     * before we decide the +car is off.
     */
    GPIO_PinState ign = HAL_GPIO_ReadPin ( IGN_GPIO_Port, IGN_Pin );
    if ( !ign  )
    {
      if( !timerIGN )
	timerIGN = HAL_GetTick ();
      else if ( (HAL_GetTick () - timerIGN) >= 10 )
	break; // break the main loop
    }


    /*
     * does nothing, just checks loop timing for diagnostics
     */
    uint32_t loopPeriod = (HAL_GetTick () - timerLoop);
    if(loopPeriod>5)
    {
      flagSlow = true;
    }
    timerLoop = HAL_GetTick ();

  }

  /*
   * Power-down loop, do anything we need to in order to cleanup before
   * we power off.
   */
  speedX12.setPosition(0);
  tachX12.setPosition(0);
  while(1)
  {
    speedX12.update();
    tachX12.update();
    if(speedX12.stopped && tachX12.stopped)
      break;
  }

  /*
   * we left the main loop, we can power down
   */
  HAL_GPIO_WritePin ( PWREN_GPIO_Port, PWREN_Pin, GPIO_PIN_RESET );
  HAL_Delay(1000);

  return 0;
}

